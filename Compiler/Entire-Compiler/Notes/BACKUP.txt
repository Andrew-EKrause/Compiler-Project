
%{
    #include <stdio.h>
    #include <stdlib.h>
    #include <string.h>
    #include "IOMngr.h"
    #include "SymTab.h"
    #include "Semantics.h"
    #include "CodeGen.h"

    extern int yylex(); /* The next token function. */
    extern char *yytext; /* The matched token text.  */
    extern int yyleng; /* The token text length.   */
    extern int yyparse();
    extern int yyerror(char *);
    void dumpTable();

    extern SymTab *table;
%}

%union {
    long val;
    char * string;
    struct ExprRes * ExprRes;
    struct InstrSeq * InstrSeq;
    struct BExprRes * BExprRes;
}

%type <string> Id
%type <InstrSeq> StmtSeq
%type <InstrSeq> Stmt
%type <InstrSeq> AssnmtStmt
%type <ExprRes> ExprL0
%type <ExprRes> ExprL1
%type <ExprRes> ExprL2
%type <ExprRes> ExprL3

%token Ident 		
%token IntLit 	
%token Int
%token Write
%token IF
%token EQ	
%token NOT_EQ
%token LT_OR_EQ
%token GT_OR_EQ
%token LT
%token GT
%token OR
%token AND

%%

Prog			            : Declarations StmtSeq						                           { Finish($2); };
Declarations	            : Dec Declarations							                           { };
            	            |											                           { };
Dec			                : Int Ident                                                            { enterName(table, yytext); }';' {};
StmtSeq 		            : Stmt StmtSeq								                           { $$ = AppendSeq($1, $2); };
    		                |											                           { $$ = NULL; };
Stmt			            : Write '(' ExprL0 ')' ';'					                           { $$ = doPrint($3); };
    			            | IF '(' ExprL0 ')' '{' StmtSeq '}'			                           { $$ = doIf($3, $6); };
                            | AssnmtStmt ';'                                                       { $$ = $1; };
AssnmtStmt			        : Id '=' ExprL0							                               { $$ = doAssign($1, $3); };
ExprL0                      : '!' ExprL1                                                           { $$ = doNegate($2); };
                            | ExprL0 OR ExprL1                                                     { $$ = doOr($1, $3); };
                            | ExprL0 AND ExprL1                                                    { $$ = doAnd($1, $3); };
      		                | ExprL0 EQ ExprL1						                               { $$ = doBExprEq($1, $3); };
                            | ExprL0 NOT_EQ ExprL1                                                 { $$ = doBExprNotEq($1, $3); };
                            | ExprL0 LT_OR_EQ ExprL1                                               { $$ = doBExprLtOrEq($1, $3); };
                            | ExprL0 GT_OR_EQ ExprL1                                               { $$ = doBExprGtOrEq($1, $3); };
                            | ExprL0 LT ExprL1                                                     { $$ = doBExprLt($1, $3); };
                            | ExprL0 GT ExprL1                                                     { $$ = doBExprGt($1, $3); };
                            | ExprL1                                                               { $$ = $1; };
ExprL1                      : '(' ExprL1 ')'                                                       { $$ = $2; };
    			            | ExprL1 '+' ExprL2						                               { $$ = doAdd($1, $3); };
    			            | ExprL1 '-' ExprL2							                           { $$ = doSubtraction($1, $3); };
    			            | ExprL2									                           { $$ = $1; };
ExprL2                      : '(' ExprL2 ')'                                                       { $$ = $2; };
    		                | ExprL2 '*' ExprL3							                           { $$ = doMult($1, $3); };
    		                | ExprL2 '/' ExprL3							                           { $$ = doDivide($1, $3); };
    		                | ExprL2 '%' ExprL3							                           { $$ = doModulo($1, $3); };
                            | ExprL2 '^' ExprL3                                                    { $$ = doExponential($1, $3); };
    		                | ExprL3									                           { $$ = $1; };
ExprL3                      : '(' ExprL3 ')'                                                       { $$ = $2; };
    		                | IntLit									                           { $$ = doIntLit(yytext); };
                            | '-'IntLit                                                            { $$ = doIntLitNeg(yytext); };
    		                | Ident									                               { $$ = doRval(yytext); };
Id			                : Ident									                               { $$ = strdup(yytext); }

%%

int yyerror(char *s) {
    writeIndicator(getCurrentColumnNum());
    writeMessage("Illegal Character in YACC");
    return 1;
}
















// /**
//  * The function returns a struct that contains a new
//  * instruction generated within the function. The
//  * function handles cases where there is a branch in
//  * the code. In this particular case, the branch occurs
//  * when there are two values that are not equal. The 
//  * label for this process is the "bne" label (branch
//  * if not equal).
//  */
// extern struct BExprRes *doBExpr(struct ExprRes *Res1, struct ExprRes *Res2) {

//     // Create a variable of type BExprRes.
//     // This stores the branch instruction.
//     struct BExprRes *bRes;
	
//     // Using the AppendSeq function, add the 
//     // Res1 and Res2 instructions to the main
//     // linked list of instructions.
//     AppendSeq(Res1->Instrs, Res2->Instrs);
    
//     // Create space for the instruction that will be
//     // generated. Create a label for the instruction.
//     bRes = (struct BExprRes *) malloc(sizeof(struct BExprRes));
//     bRes->Label = GenLabel();
    
//     // Call the AppendSeq function again to add the 
//     // newly formed instruction to the linked list
//     // of instructions. Set the instruction part 
//     // of the bRes variable to the instruction 
//     // component of Res1.
//     AppendSeq(Res1->Instrs, GenInstr(NULL, "bne", TmpRegName(Res1->Reg), TmpRegName(Res2->Reg), bRes->Label));
//     bRes->Instrs = Res1->Instrs;
    
//     // Release the temporary registers 
//     // for reuse after the instruction 
//     // is created with the registers.
//     ReleaseTmpReg(Res1->Reg);
//   	ReleaseTmpReg(Res2->Reg);
    
//     // Free the structs used for the 
//     // registers to free up memory. 
//     free(Res1);
//     free(Res2);

//     // Return the bRes variable 
//     // from the function.
//     return bRes;
// }



















// // --> NOT SURE WHAT THIS IS YET...LEAVE COMMENTED OUT FOR NOW!!!
// extern struct InstrSeq *doIf(struct ExprRes *res1, struct ExprRes *res2, struct InstrSeq *seq) {
//     struct InstrSeq *seq2;
//     char * label;
//     label = GenLabel();
//     AppendSeq(res1->Instrs, res2->Instrs);
//     AppendSeq(res1->Instrs, GenInstr(NULL, "bne", TmpRegName(res1->Reg), TmpRegName(res2->Reg), label));
//     seq2 = AppendSeq(res1->Instrs, seq);
//     AppendSeq(seq2, GenInstr(label, NULL, NULL, NULL, NULL));
//     ReleaseTmpReg(res1->Reg);
//     ReleaseTmpReg(res2->Reg);
//     free(res1);
//     free(res2);
//     return seq2;
// }



























/* ================================================================== */
/* SECTION FOR ADDING ARGUMENTS AND EXPRESSIONS TO LISTS: APPEND TO */
/* ARGUMENT LIST, AND APPEND TO EXPRESSION LIST. */
/* ================================================================== */

// --> MAY NOT NEED THIS!!!
// /**
//  * APPEND TO ARGUMENT LIST
//  * 
//  * DESCRIPTION...
//  */
// extern struct Node *appendToArgList(char *c, struct Node *next) {
    
//     struct Node *curr = (struct Node *)malloc(sizeof(struct Node));

//     curr->name = strdup(c);
//     curr->next = next;

//     return curr;
// }

// /**
//  * APPEND TO EXPRESSION LIST
//  * 
//  * DESCRIPTION...
//  */
// extern struct Node *appendToExprList(struct ExprRes *Res1, struct Node *next) {
   
//     struct Node *curr = (struct Node *)malloc(sizeof(struct Node));

//     curr->name = Res1;
//     curr->next = next;

//     return curr;
// }
















// // --> THIS MAY BE THE PRINT THAT YOU WILL ACTUALLY WANT TO USE!!!
// struct InstrSeq *doPrint(struct Node *node) {

//     struct InstrSeq *code = (struct InstrSeq *)malloc(sizeof(struct InstrSeq));
//     struct Node *curr = node;

//     while (curr) {

//         struct ExprRes *currInstr = (struct ExprRes *)curr->name;

//         AppendSeq(code, currInstr->Instrs);
//         AppendSeq(code, GenInstr(NULL, "li", "$v0", "1", NULL));
//         AppendSeq(code, GenInstr(NULL, "move", "$a0", TmpRegName(currInstr->Reg), NULL));
//         AppendSeq(code, GenInstr(NULL, "syscall", NULL, NULL, NULL));

//         ReleaseTmpReg(currInstr->Reg);
//         free(currInstr);
//         curr = curr->next;
//     }

//     return code;
// }

// ============================== --> LEFT OFF COMMENTING HERE!!! <-- ==============================



















// /**
//  * IF (series of instructions)
//  * 
//  * The function returns a struct that contains a new
//  * instruction generated within the function. The
//  * function handles cases where there is a conditional
//  * statement in the C-like code (if-statement).
//  */
// extern struct InstrSeq *doIf(struct ExprRes *Res, struct InstrSeq *seq) {
    
//     // Create a struct of type InstrSeq to store
//     // the new instruction being created.
//     struct InstrSeq * seq2;

//     // Call the AppendSeq function in order to
//     // store the instruction data and add it
//     // to the linked list of instructions.
//     seq2 = AppendSeq(Res->Instrs, seq);
//     AppendSeq(seq2, GenInstr(Res->Label, NULL, NULL, NULL, NULL));
    
//     // Free the branch register used to 
//     // free up memory space and return
//     // the variable from the function.
//     free(Res);
//     return seq2;
// }

// --> THIS WAS IN THE DOIF FUNCTION THAT YOU CURRENTLY HAVE IN YOUR SEMANTICS FILE!!!
// AppendSeq(Res->Instrs, GenInstr(NULL, "sne", TmpRegName(Res->Reg), TmpRegName(Res->Reg), "$zero"));
