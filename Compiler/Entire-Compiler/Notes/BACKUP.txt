
%{
    #include <stdio.h>
    #include <stdlib.h>
    #include <string.h>
    #include "IOMngr.h"
    #include "SymTab.h"
    #include "Semantics.h"
    #include "CodeGen.h"

    extern int yylex(); /* The next token function. */
    extern char *yytext; /* The matched token text.  */
    extern int yyleng; /* The token text length.   */
    extern int yyparse();
    extern int yyerror(char *);
    void dumpTable();

    extern SymTab *table;
%}

%union {
    long val;
    char * string;
    struct ExprRes * ExprRes;
    struct InstrSeq * InstrSeq;
    struct BExprRes * BExprRes;
}

%type <string> Id
%type <InstrSeq> StmtSeq
%type <InstrSeq> Stmt
%type <InstrSeq> AssnmtStmt
%type <ExprRes> ExprL0
%type <ExprRes> ExprL1
%type <ExprRes> ExprL2
%type <ExprRes> ExprL3

%token Ident 		
%token IntLit 	
%token Int
%token Write
%token IF
%token EQ	
%token NOT_EQ
%token LT_OR_EQ
%token GT_OR_EQ
%token LT
%token GT
%token OR
%token AND

%%

Prog			            : Declarations StmtSeq						                           { Finish($2); };
Declarations	            : Dec Declarations							                           { };
            	            |											                           { };
Dec			                : Int Ident                                                            { enterName(table, yytext); }';' {};
StmtSeq 		            : Stmt StmtSeq								                           { $$ = AppendSeq($1, $2); };
    		                |											                           { $$ = NULL; };
Stmt			            : Write '(' ExprL0 ')' ';'					                           { $$ = doPrint($3); };
    			            | IF '(' ExprL0 ')' '{' StmtSeq '}'			                           { $$ = doIf($3, $6); };
                            | AssnmtStmt ';'                                                       { $$ = $1; };
AssnmtStmt			        : Id '=' ExprL0							                               { $$ = doAssign($1, $3); };
ExprL0                      : '!' ExprL1                                                           { $$ = doNegate($2); };
                            | ExprL0 OR ExprL1                                                     { $$ = doOr($1, $3); };
                            | ExprL0 AND ExprL1                                                    { $$ = doAnd($1, $3); };
      		                | ExprL0 EQ ExprL1						                               { $$ = doBExprEq($1, $3); };
                            | ExprL0 NOT_EQ ExprL1                                                 { $$ = doBExprNotEq($1, $3); };
                            | ExprL0 LT_OR_EQ ExprL1                                               { $$ = doBExprLtOrEq($1, $3); };
                            | ExprL0 GT_OR_EQ ExprL1                                               { $$ = doBExprGtOrEq($1, $3); };
                            | ExprL0 LT ExprL1                                                     { $$ = doBExprLt($1, $3); };
                            | ExprL0 GT ExprL1                                                     { $$ = doBExprGt($1, $3); };
                            | ExprL1                                                               { $$ = $1; };
ExprL1                      : '(' ExprL1 ')'                                                       { $$ = $2; };
    			            | ExprL1 '+' ExprL2						                               { $$ = doAdd($1, $3); };
    			            | ExprL1 '-' ExprL2							                           { $$ = doSubtraction($1, $3); };
    			            | ExprL2									                           { $$ = $1; };
ExprL2                      : '(' ExprL2 ')'                                                       { $$ = $2; };
    		                | ExprL2 '*' ExprL3							                           { $$ = doMult($1, $3); };
    		                | ExprL2 '/' ExprL3							                           { $$ = doDivide($1, $3); };
    		                | ExprL2 '%' ExprL3							                           { $$ = doModulo($1, $3); };
                            | ExprL2 '^' ExprL3                                                    { $$ = doExponential($1, $3); };
    		                | ExprL3									                           { $$ = $1; };
ExprL3                      : '(' ExprL3 ')'                                                       { $$ = $2; };
    		                | IntLit									                           { $$ = doIntLit(yytext); };
                            | '-'IntLit                                                            { $$ = doIntLitNeg(yytext); };
    		                | Ident									                               { $$ = doRval(yytext); };
Id			                : Ident									                               { $$ = strdup(yytext); }

%%

int yyerror(char *s) {
    writeIndicator(getCurrentColumnNum());
    writeMessage("Illegal Character in YACC");
    return 1;
}
















// /**
//  * The function returns a struct that contains a new
//  * instruction generated within the function. The
//  * function handles cases where there is a branch in
//  * the code. In this particular case, the branch occurs
//  * when there are two values that are not equal. The 
//  * label for this process is the "bne" label (branch
//  * if not equal).
//  */
// extern struct BExprRes *doBExpr(struct ExprRes *Res1, struct ExprRes *Res2) {

//     // Create a variable of type BExprRes.
//     // This stores the branch instruction.
//     struct BExprRes *bRes;
	
//     // Using the AppendSeq function, add the 
//     // Res1 and Res2 instructions to the main
//     // linked list of instructions.
//     AppendSeq(Res1->Instrs, Res2->Instrs);
    
//     // Create space for the instruction that will be
//     // generated. Create a label for the instruction.
//     bRes = (struct BExprRes *) malloc(sizeof(struct BExprRes));
//     bRes->Label = GenLabel();
    
//     // Call the AppendSeq function again to add the 
//     // newly formed instruction to the linked list
//     // of instructions. Set the instruction part 
//     // of the bRes variable to the instruction 
//     // component of Res1.
//     AppendSeq(Res1->Instrs, GenInstr(NULL, "bne", TmpRegName(Res1->Reg), TmpRegName(Res2->Reg), bRes->Label));
//     bRes->Instrs = Res1->Instrs;
    
//     // Release the temporary registers 
//     // for reuse after the instruction 
//     // is created with the registers.
//     ReleaseTmpReg(Res1->Reg);
//   	ReleaseTmpReg(Res2->Reg);
    
//     // Free the structs used for the 
//     // registers to free up memory. 
//     free(Res1);
//     free(Res2);

//     // Return the bRes variable 
//     // from the function.
//     return bRes;
// }



















// // --> NOT SURE WHAT THIS IS YET...LEAVE COMMENTED OUT FOR NOW!!!
// extern struct InstrSeq *doIf(struct ExprRes *res1, struct ExprRes *res2, struct InstrSeq *seq) {
//     struct InstrSeq *seq2;
//     char * label;
//     label = GenLabel();
//     AppendSeq(res1->Instrs, res2->Instrs);
//     AppendSeq(res1->Instrs, GenInstr(NULL, "bne", TmpRegName(res1->Reg), TmpRegName(res2->Reg), label));
//     seq2 = AppendSeq(res1->Instrs, seq);
//     AppendSeq(seq2, GenInstr(label, NULL, NULL, NULL, NULL));
//     ReleaseTmpReg(res1->Reg);
//     ReleaseTmpReg(res2->Reg);
//     free(res1);
//     free(res2);
//     return seq2;
// }



























/* ================================================================== */
/* SECTION FOR ADDING ARGUMENTS AND EXPRESSIONS TO LISTS: APPEND TO */
/* ARGUMENT LIST, AND APPEND TO EXPRESSION LIST. */
/* ================================================================== */

// --> MAY NOT NEED THIS!!!
// /**
//  * APPEND TO ARGUMENT LIST
//  * 
//  * DESCRIPTION...
//  */
// extern struct Node *appendToArgList(char *c, struct Node *next) {
    
//     struct Node *curr = (struct Node *)malloc(sizeof(struct Node));

//     curr->name = strdup(c);
//     curr->next = next;

//     return curr;
// }

// /**
//  * APPEND TO EXPRESSION LIST
//  * 
//  * DESCRIPTION...
//  */
// extern struct Node *appendToExprList(struct ExprRes *Res1, struct Node *next) {
   
//     struct Node *curr = (struct Node *)malloc(sizeof(struct Node));

//     curr->name = Res1;
//     curr->next = next;

//     return curr;
// }
















// // --> THIS MAY BE THE PRINT THAT YOU WILL ACTUALLY WANT TO USE!!!
// struct InstrSeq *doPrint(struct Node *node) {

//     struct InstrSeq *code = (struct InstrSeq *)malloc(sizeof(struct InstrSeq));
//     struct Node *curr = node;

//     while (curr) {

//         struct ExprRes *currInstr = (struct ExprRes *)curr->name;

//         AppendSeq(code, currInstr->Instrs);
//         AppendSeq(code, GenInstr(NULL, "li", "$v0", "1", NULL));
//         AppendSeq(code, GenInstr(NULL, "move", "$a0", TmpRegName(currInstr->Reg), NULL));
//         AppendSeq(code, GenInstr(NULL, "syscall", NULL, NULL, NULL));

//         ReleaseTmpReg(currInstr->Reg);
//         free(currInstr);
//         curr = curr->next;
//     }

//     return code;
// }

// ============================== --> LEFT OFF COMMENTING HERE!!! <-- ==============================



















// /**
//  * IF (series of instructions)
//  * 
//  * The function returns a struct that contains a new
//  * instruction generated within the function. The
//  * function handles cases where there is a conditional
//  * statement in the C-like code (if-statement).
//  */
// extern struct InstrSeq *doIf(struct ExprRes *Res, struct InstrSeq *seq) {
    
//     // Create a struct of type InstrSeq to store
//     // the new instruction being created.
//     struct InstrSeq * seq2;

//     // Call the AppendSeq function in order to
//     // store the instruction data and add it
//     // to the linked list of instructions.
//     seq2 = AppendSeq(Res->Instrs, seq);
//     AppendSeq(seq2, GenInstr(Res->Label, NULL, NULL, NULL, NULL));
    
//     // Free the branch register used to 
//     // free up memory space and return
//     // the variable from the function.
//     free(Res);
//     return seq2;
// }

// --> THIS WAS IN THE DOIF FUNCTION THAT YOU CURRENTLY HAVE IN YOUR SEMANTICS FILE!!!
// AppendSeq(Res->Instrs, GenInstr(NULL, "sne", TmpRegName(Res->Reg), TmpRegName(Res->Reg), "$zero"));






















// /**
//  * PRINT (series of instructions)
//  * 
//  * The function returns a struct that contains a new
//  * instruction generated within the function. The
//  * function handles cases where the data needs to be
//  * printed out to the console (usually in an editor).
//  * There are a series of instructions that are used
//  * to print out values in assembly. Labels like "li",
//  * "la", "move", and "syscall" are used for this process.
//  */
// extern struct InstrSeq *doPrint(struct ExprRes *Expr) { 

//     // Create a struct of type ExprRes to store
//     // the new instruction being created.
//     struct InstrSeq *code;
    
//     // Store the instruction in the expression result
//     // within the code variable that was created.
//     code = Expr->Instrs;
  
//     // Add the MIPS assembly code to the linked list of instructions.
//     AppendSeq(code, GenInstr(NULL, "li", "$v0", "1", NULL));
//     AppendSeq(code, GenInstr(NULL, "move", "$a0", TmpRegName(Expr->Reg), NULL));
//     AppendSeq(code, GenInstr(NULL, "syscall", NULL, NULL, NULL));

//     // Add more MIPS assembly code to complete the process of adding
//     // the proper procedures to enable printing out to the screen.
//     AppendSeq(code, GenInstr(NULL, "li", "$v0", "4", NULL));
//     AppendSeq(code, GenInstr(NULL, "la", "$a0", "_nl", NULL));
//     AppendSeq(code, GenInstr(NULL, "syscall", NULL, NULL, NULL));

//     // Call the functions below to indicate 
//     // that the registers used in the print 
//     // operation are now free to use again. 
//     ReleaseTmpReg(Expr->Reg);
//     free(Expr);

//     // Return the code variable with the instruction data.
//     return code;
// }















// /**
//  * PRINTLINES
//  * 
//  * DESCRIPTION...
//  */
// extern struct InstrSeq *doPrintlines(struct ExprRes *Res) {

//     struct InstrSeq *code = NULL; // (struct InstrSeq *)malloc(sizeof(struct InstrSeq));
//     // struct InstrSeq *code = NULL;
//     int reg = AvailTmpReg();
//     AppendSeq(code, Res->Instrs);
//     AppendSeq(code, GenInstr(NULL, "move", TmpRegName(reg), TmpRegName(Res->Reg), NULL));

//     char *label = GenLabel();
//     char *label2 = GenLabel();

//     AppendSeq(code, GenInstr(NULL, "beq", "$zero", TmpRegName(reg), label2));
//     AppendSeq(code, GenInstr(label, NULL, NULL, NULL, NULL)); // Label to jump back to, based on amount of new lines desired;

//     AppendSeq(code, GenInstr(NULL, "li", "$v0", "4", NULL));
//     AppendSeq(code, GenInstr(NULL, "la", "$a0", "_nl", NULL));
//     AppendSeq(code, GenInstr(NULL, "syscall", NULL, NULL, NULL));

//     AppendSeq(code, GenInstr(NULL, "subi", TmpRegName(reg), TmpRegName(reg), "1"));
//     AppendSeq(code, GenInstr(NULL, "bne", "$zero", TmpRegName(reg), label));
//     AppendSeq(code, GenInstr(label2, NULL, NULL, NULL, NULL));

//     ReleaseTmpReg(reg);
//     ReleaseTmpReg(Res->Reg);
//     free(Res);

//     return code;
// }
















// /**
//  * PRINTSPACES
//  * 
//  * DESCRIPTION...
//  */
// extern struct InstrSeq *doPrintspaces(struct ExprRes *Res) {
    
//     // struct InstrSeq *code = (struct InstrSeq *)malloc(sizeof(struct InstrSeq));
//     struct InstrSeq *code = NULL;
//     int reg = AvailTmpReg();
    
//     AppendSeq(code, Res->Instrs);
//     AppendSeq(code, GenInstr(NULL, "move", TmpRegName(reg), TmpRegName(Res->Reg), NULL));

//     char *label1 = GenLabel();
//     char *label2 = GenLabel();

//     AppendSeq(code, GenInstr(NULL, "beq", "$zero", TmpRegName(reg), label2));
//     AppendSeq(code, GenInstr(label1, NULL, NULL, NULL, NULL)); // Label to jump back to, based on amount of new lines desired;

//     AppendSeq(code, GenInstr(NULL, "li", "$v0", "11", NULL));
//     AppendSeq(code, GenInstr(NULL, "la", "$a0", "32", NULL));
//     AppendSeq(code, GenInstr(NULL, "syscall", NULL, NULL, NULL));

//     AppendSeq(code, GenInstr(NULL, "subi", TmpRegName(reg), TmpRegName(reg), "1"));
//     AppendSeq(code, GenInstr(NULL, "bne", "$zero", TmpRegName(reg), label1));
//     AppendSeq(code, GenInstr(label2, NULL, NULL, NULL, NULL));

//     ReleaseTmpReg(reg);
//     ReleaseTmpReg(Res->Reg);

//     free(Res);
//     return code;
// }
























/**
 * PRINT and PRINT EXPRESSIONS
 * 
 * The function returns a struct that contains a new
 * instruction generated within the function. The
 * function handles cases where the data needs to be
 * printed out to the console (usually in an editor).
 * There are a series of instructions that are used
 * to print out values in assembly. Labels like "li",
 * "la", "move", and "syscall" are used for this process.
 * The function handles cases when users want to print 
 * out a single item or multiple items. 
 */
extern struct InstrSeq *doPrintExpressions(struct ExprResList *list) {

    // Create a variable of type instruction sequence, an expression
    // list variable, and a variable to represent a boolean.
    struct InstrSeq *resultInstruction = NULL;
    struct ExprResList *listOfExprs = list;
    // int includeNewline = 1; // --> LIKELY DELETE LATER!!!

    // // Include a check to determine if a newline should be printed.
    // // If there is more than one item in the list of expressions.
    // // This check is performed to determine whether or not a newline
    // // needs to be printed (newlines are printed after single-item 
    // // expressions, and not after multiple-item expressions).
    // if(listOfExprs->Next) {
    //     includeNewline = 0;
    // } // --> LIKELY DELETE LATER!!!

    // Loop through the list of expressions and add assembly code to 
    // the linked list of instructions to print out each item in the
    // expression.
    while(listOfExprs) {

        // Set the variable equal to the call for adding the instructions to the 
        resultInstruction = AppendSeq(resultInstruction, listOfExprs->Expr->Instrs);

        // Call the function multiple times to print out a given item in the expression.
        AppendSeq(resultInstruction, GenInstr(NULL, "add", "$a0", TmpRegName(listOfExprs->Expr->Reg), "$zero"));
        AppendSeq(resultInstruction, GenInstr(NULL, "li", "$v0", "1", NULL)); // --> 1 is the syscall number for printing an integer.
        AppendSeq(resultInstruction, GenInstr(NULL, "syscall", NULL, NULL, NULL));

        // Call the function multiple times to print out a space in
        // order to separate item being printed out in the expression.
        AppendSeq(resultInstruction, GenInstr(NULL, "li", "$v0", "11", NULL)); // --> 11 is the syscall number for printing a character.
        AppendSeq(resultInstruction, GenInstr(NULL, "la", "$a0", "_spc", NULL)); // --> 32 is the ASCII character for a space. I use "_spc" here instead.
        AppendSeq(resultInstruction, GenInstr(NULL, "syscall", NULL, NULL, NULL));

        // Release the temporary registers so that they
        // can be used again, and free the list of 
        // expressions struct.
        ReleaseTmpReg(listOfExprs->Expr->Reg);
        free(listOfExprs->Expr);

        // Move to the next item in the list of expressions.
        list = listOfExprs;
        listOfExprs = listOfExprs->Next;
        free(list); // --> KEEP AN EYE ON THIS ONE!!!
    }

    // // If the newline variable is equal to 1, print a newline.
    // // This indicates that we do not have more than one item in
    // // the expression list and therefore do want a newline in
    // // this case.
    // if(includeNewline) {

    //     // Append assembly instructions to the linked list of instructions to 
    //     // print out a newline. This is done only when there is a single item
    //     // in the print statement.
    //     AppendSeq(resultInstruction, GenInstr(NULL, "li", "$v0", "4", NULL)); // --> 4 is the ASCII character for a newline.
    //     AppendSeq(resultInstruction, GenInstr(NULL, "la", "$a0", "_nl", NULL)); // --> Include the newline character.
    //     AppendSeq(resultInstruction, GenInstr(NULL, "syscall", NULL, NULL, NULL));
    // } // --> LIKELY DELETE LATER!!!

    // Return the resulting instructions.
    return resultInstruction;
}

















/**
 * IF
 * 
 * The function returns a struct that contains a new
 * instruction generated within the function. The
 * function handles cases where there is a conditional
 * statement in the C-like code (if-statement).
 */
extern struct InstrSeq *doIf(struct ExprRes *Res, struct InstrSeq *seq) {

    // Create a new struct of type InstrSeq to add the 
    // assembly instructions to as they are generated
    // in this function.
    struct InstrSeq *seq2;
    char *label = GenLabel();

    int reg = AvailTmpReg();
    seq2 = AppendSeq(Res->Instrs, GenInstr(NULL, "sne", TmpRegName(reg), TmpRegName(Res->Reg), "$zero"));

    // Call the function to add the generated assembly instructions to 
    // the linked list of instructions that will be returned from the 
    // function.
    AppendSeq(seq2, GenInstr(NULL, "beq", TmpRegName(reg), "$zero", label));
    // seq2 = AppendSeq(Res->Instrs, seq); // --> MAYBE DELETE LATER!!!
    AppendSeq(seq2, seq);
    AppendSeq(seq2, GenInstr(label, NULL, NULL, NULL, NULL));

    ReleaseTmpReg(Res->Reg);
    ReleaseTmpReg(reg);

    // Free the ExprRes struct and
    // return the instruction sequence.
    free(Res);
    free(label);
    return seq2;
}



















/**
 * WHILE 
 * 
 * The function is used to help complete the 
 * process of generating assembly code for 
 * a while-loop in the C-like language that
 * the compiler processes. A struct is returned
 * from the function that contains the assembly
 * code instructions that are produced.
 */
extern struct InstrSeq *doWhile(struct ExprRes *Res, struct InstrSeq *seq) {
   
    // Create a new variable of type InstrSeq and allocate
    // space for it. The variable is used to store the 
    // assembly code instructions that are generated by the
    // function. 
    struct InstrSeq *code = (struct InstrSeq *)malloc(sizeof(struct InstrSeq));

    // Create two new labels for proper jumps 
    // in the assembly code for the while loop.
    char *label1 = GenLabel();
    char *label2 = GenLabel();

    // Call the function multiple times to generate assembly code
    // for the while loop and put it in the linked list of instructions
    // that will be returned from this function.
    AppendSeq(code, GenInstr(label1, NULL, NULL, NULL, NULL));
    AppendSeq(code, Res->Instrs);
    AppendSeq(code, GenInstr(NULL, "beq", "$zero", TmpRegName(Res->Reg), label2));
    AppendSeq(code, seq);
    AppendSeq(code, GenInstr(NULL, "j", label1, NULL, NULL));
    AppendSeq(code, GenInstr(label2, NULL, NULL, NULL, NULL));

    //ReleaseTmpReg(Res->Reg); // --> KEEP AN EYE ON THIS!!!

    // Free the ExprRes struct and return 
    // the linked list of generated assembly
    // instructions 
    free(label1);
    free(label2);
    free(Res);
    return code;
}




















/**
 * INTEGER LITERAL: NEGATIVE
 * 
 * The function returns a struct that contains a new 
 * instruction generated within the function. The 
 * function handles cases where a negative int literal
 * is being evaluated. The function ensures that the 
 * negative int literal is added into a register via
 * the "li" label (It loads an immediate value into
 * a register). The value is then multiplied by negative
 * one to ensure that it is read as negative in MIPS
 * assembly.
 */
extern struct ExprRes *doIntLitNeg(struct ExprRes *Res) {

    // // Create a struct of type ExprRes to store 
    // // the new instruction being created.
    // struct ExprRes *res;
  
    // // Allocate space for the struct, find the available registers to
    // // use for creation of the instruction, and generate the instruction.
    // res = (struct ExprRes *) malloc(sizeof(struct ExprRes));
    // res->Reg = AvailTmpReg();

    // Multiply the expression by negative one in order to ensure that the
    // negative value is applied to the expression result passed into this
    // function.
    // res->Instrs = AppendSeq(Res->Instrs, GenInstr(NULL, "mul", TmpRegName(res->Reg), TmpRegName(Res->Reg), "-1"));
    AppendSeq(Res->Instrs, GenInstr(NULL, "mul", TmpRegName(Res->Reg), TmpRegName(Res->Reg), "-1"));


    // free(Res); // --> DO NOT KNOW IF YOU NEED TO FREE THIS!!!

    // Return the resulting instruction.
    return Res;
}

























// BACKUP...MAY DELETE LATER FOR ExprEval.y FILE.
// =====================================================================================================================================
// Stmt			            : Read '(' IdentList ')' ';'                                           { $$ = doRead($3); };
//                          | Write '(' ExprList ')' ';'                                           { $$ = doPrintExpressions($3); };
// 			                | IF '(' ExprL0 ')' '{' StmtSeq '}'			                           { $$ = doIf($3, $6); };
//                          | AssnmtStmt ';'                                                       { $$ = $1; };

// %token Write
// Print '(' ExprL0 ')' ';'					                           { $$ = doPrint($3); }; // --> DO NOT THINK YOU NEED THIS NOW GIVEN THAT YOU HAVE EXPR LIST WORK WITH SINGLE PRINTS.
// =====================================================================================================================================

// BACKUP FOR Semantics.h FILE
// extern struct InstrSeq *doPrint(struct ExprRes *Expr);































%{
    #include <stdio.h>
    #include <stdlib.h>
    #include <string.h>
    #include "IOMngr.h"
    #include "SymTab.h"
    #include "Semantics.h"
    #include "CodeGen.h"

    extern int yylex(); /* The next token function. */
    extern char *yytext; /* The matched token text. */
    extern int yyleng; /* The token text length. */
    extern int yyparse(); /* Call function to parse data. */
    extern int yyerror(char *); /* The error report function. */
    void dumpTable(); /* Remove a table to free up memory. */

    extern SymTab *table;

    /* // --> REPLACE IdentList WITH ReadList, WHICH IS JUST A LIST OF INSTRUCTIONS. YOU */
    /* // --> NEED THIS IN ORDER TO BE ABLE TO USE ARRAYS WITH THE Read() FUNCTIONALITY!!! */
%}

%union {
    long val;
    char * string;
    struct ExprRes * ExprRes;
    struct InstrSeq * InstrSeq;
    struct IdList * IdList;
    struct ExprResList * ExprResList;
}

%type <InstrSeq> StmtSeq
%type <InstrSeq> Stmt
%type <InstrSeq> AssnmtStmt
%type <InstrSeq> ArrayAssnmtStmt
%type <ExprResList> ExprList
%type <string> StrList
%type <ExprRes> ExprL0
%type <ExprRes> ExprL1
%type <ExprRes> ExprL2
%type <ExprRes> ExprL3
%type <ExprRes> ExprL4
%type <ExprRes> ExprL5
%type <ExprRes> ExprL6
%type <ExprRes> ExprL7
%type <IdList> IdentList
%type <string> Id

%token Int
%token Ident	
%token StrLit	
%token Print
%token Printstrings
%token Printlines
%token Printspaces
%token Read
%token IF
%token ELSE
%token WHILE
%token FOR
%token OR
%token AND
%token NOT_EQ
%token EQ
%token LT_OR_EQ
%token GT_OR_EQ
%token LT
%token GT
%token IntLit	

%%

Prog			            : Declarations StmtSeq						                           { Finish($2); };
Declarations	            : Dec Declarations							                           { };
            	            |											                           { };
                            
Dec			                : Int Ident                                                            { enterName(table, yytext); }';' {};
StmtSeq 		            : Stmt StmtSeq								                           { $$ = AppendSeq($1, $2); };
    		                |											                           { $$ = NULL; };

Stmt			            : Print '(' ExprList ')' ';'                                           { $$ = doPrintExpressions($3); };
                            | Printstrings '(' StrList ')' ';'                                     { $$ = doPrintStrings($3); };
                            | Printlines '(' ExprL0 ')' ';'                                        { $$ = doPrintformat($3, newline); };
                            | Printspaces '(' ExprL0 ')' ';'                                       { $$ = doPrintformat($3, space); };
                            | Read '(' IdentList ')' ';'                                           { $$ = doRead($3); };
                            
                            | IF '(' ExprL0 ')' '{' StmtSeq '}'                                    { $$ = doIf($3, $6); };
                            | IF '(' ExprL0 ')' '{' StmtSeq '}' ELSE '{' StmtSeq '}'               { $$ = doIfElse($3, $6, $10); };
                            | WHILE '(' ExprL0 ')' '{' StmtSeq '}'                                 { $$ = doWhile($3, $6); };
                            | FOR '(' AssnmtStmt ';' ExprL0 ';' AssnmtStmt ')' '{' StmtSeq '}'     { $$ = doFor($3, $5, $7, $10); };
                            | AssnmtStmt ';'                                                       { $$ = $1; };
                            | ArrayAssnmtStmt ';'                                                  { $$ = $1; };

AssnmtStmt			        : Id '=' ExprL0							                               { $$ = doAssign($1, $3); };

ArrayAssnmtStmt             : Id '[' ExprL0 ']' '=' ExprL0                                         { $$ = doArrayAssign($1, $3); };
                            | Id '[' ExprL0 ']' '[' ExprL0 ']' '=' ExprL0                          {};

ExprList                    : ExprL0 ',' ExprList                                                  { $$ = createExprList($1, $3); };
                            | ExprL0                                                               { $$ = createExprList($1, NULL); };

ExprL0                      : ExprL0 OR ExprL1                                                     { $$ = doBooleanOps($1, $3, or); };
                            | ExprL0 AND ExprL1                                                    { $$ = doBooleanOps($1, $3, and); };
                            | ExprL1                                                               { $$ = $1; };

ExprL1                      : '!' ExprL2                                                           { $$ = doBooleanOps($2, NULL, not); };
                            | ExprL2                                                               { $$ = $1; };

ExprL2                      : ExprL2 NOT_EQ ExprL3                                                 { $$ = doEqualityOps($1, $3, "sne"); };
      		                | ExprL2 EQ ExprL3					                                   { $$ = doEqualityOps($1, $3, "seq"); };
                            | ExprL2 LT_OR_EQ ExprL3                                               { $$ = doEqualityOps($1, $3, "sle"); };
                            | ExprL2 GT_OR_EQ ExprL3                                               { $$ = doEqualityOps($1, $3, "sge"); };
                            | ExprL2 LT ExprL3                                                     { $$ = doEqualityOps($1, $3, "slt"); };
                            | ExprL2 GT ExprL3                                                     { $$ = doEqualityOps($1, $3, "sgt"); };
                            | ExprL3                                                               { $$ = $1; };

ExprL3                      : ExprL3 '+' ExprL4						                               { $$ = doArithmeticOps($1, $3, "add"); };
    			            | ExprL3 '-' ExprL4							                           { $$ = doArithmeticOps($1, $3, "sub"); };
    			            | ExprL4									                           { $$ = $1; };

ExprL4                      : ExprL4 '*' ExprL5							                           { $$ = doArithmeticOps($1, $3, "mul"); };
    		                | ExprL4 '/' ExprL5							                           { $$ = doArithmeticOps($1, $3, "div"); };
    		                | ExprL4 '%' ExprL5							                           { $$ = doModulo($1, $3); };
                            | ExprL5                                                               { $$ = $1; };

ExprL5                      : ExprL6 '^' ExprL5                                                    { $$ = doExponential($1, $3); };
    		                | ExprL6									                           { $$ = $1; };

ExprL6                      : '(' ExprL0 ')'                                                       { $$ = $2; };
                            | ExprL7                                                               { $$ = $1; };

ExprL7    		            : '-'ExprL6                                                            { $$ = doIntLitNeg($2); };
                            | IntLit									                           { $$ = doIntLit(yytext); };
    		                | Ident									                               { $$ = doRval(yytext); };

IdentList                   : Id ',' IdentList                                                     { $$ = createIdentList($1, $3); };
                            | Id                                                                   { $$ = createIdentList($1, NULL); };

StrList                     : StrLit                                                               { $$ = strdup(yytext); };
Id			                : Ident									                               { $$ = strdup(yytext); };

%%

int yyerror(char *s) {
    writeIndicator(getCurrentColumnNum());
    writeMessage("Illegal Character in YACC");
    return 1;
}





















// --> WAS ORIGINALLY IN SEMANTICS.H FILE
// extern struct InstrSeq *doRead(struct IdList *entry); // --> MAYBE DELETE LATER!!!
// extern struct IdList *createIdentList(char *idName, struct IdList *list); // --> MAYBE DELETE LATER!!!
//
// --> WAS ORIGINALLY IN SEMANTICS.C FILE
// /** // --> MAYBE DELETE LATER!!!
//  * READ
//  * 
//  * The read function takes in a value that 
//  * is entered by the user and stores it in
//  * a declared variable. This function is 
//  * useful in cases where user input needs
//  * to be read in to a program. The function
//  * loops through a list of identifiers to 
//  * complete the read functionality. 
//  */
// extern struct InstrSeq *doRead(struct IdList *entry) {
  
//     // Create a struct of type InstrSeq and reserve
//     // space for it. This will store the instructions
//     // generated in this function. Also create another 
//     // struct of type IdList to represent the number 
//     // of values that can be entered.
//     struct InstrSeq *code = malloc(sizeof(struct InstrSeq));
//     struct IdList *curr = entry;

//     // There is another entry for a value that will 
//     // be entered by the user, generate a series of
//     // instructions to store the values that will be
//     // entered.
//     while (curr) {

//         // Call the functions multiple times to generate
//         // assembly instructions to store the values that
//         // will be entered into the read function.
//         AppendSeq(code, GenInstr(NULL, "li", "$v0", "5", NULL));
//         AppendSeq(code, GenInstr(NULL, "syscall", NULL, NULL, NULL));
//         AppendSeq(code, GenInstr(NULL, "sw", "$v0", curr->TheEntry->name, NULL));

//         // Free the entry name and current
//         // entry after it is entered into
//         // the assembly code being generated.
//         free(curr->TheEntry->name); 
//         free(curr->TheEntry); 

//         // Move to the next entry in
//         // the list of identifiers.
//         entry = curr;
//         curr = curr->Next;

//         // Lastly, free the entry
//         // struct itself.
//         free(entry);
//     }

//     // Return the linked list of
//     // instructions that were
//     // generated in the function.
//     return code;
// }

// /** // --> MAYBE DELETE LATER!!!
//  * {READ} - HELPER FUNCTION
//  * 
//  * The function is used to help complete the 
//  * READ functionality of the compiler. The
//  * function helps to create a list of identifers
//  * that is used to run the read function of the
//  * C-like language.
//  */
// extern struct IdList *createIdentList(char *idName, struct IdList *list) {

//     // Create a new IdList to return from the
//     // function and reserve space for the list.
//     struct IdList *newList = malloc(sizeof(struct IdList));

//     // Set the attributes of the list, and reserve
//     // space for the SymEntry and string of characters.
//     newList->Next = list;
//     newList->TheEntry = malloc(sizeof(SymEntry));
//     newList->TheEntry->name = strdup(idName);

//     // Return the list of identifiers
//     // from the function.
//     return newList;
// }
